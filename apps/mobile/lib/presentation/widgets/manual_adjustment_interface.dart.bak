import 'package:flutter/material.dart';
import '../../data/models/edge_detection_result.dart';

/// Interface for manually adjusting edge detection results
class ManualAdjustmentInterface extends StatefulWidget {
  const ManualAdjustmentInterface({
    super.key,
    required this.currentResult,
    required this.viewSize,
    this.onResultChanged,
    this.onResetToAuto,
    this.onConfirm,
    this.onCancel,
    this.showInstructions = true,
  });

  final EdgeDetectionResult? currentResult;
  final Size viewSize;
  final Function(EdgeDetectionResult)? onResultChanged;
  final VoidCallback? onResetToAuto;
  final Function(EdgeDetectionResult)? onConfirm;
  final VoidCallback? onCancel;
  final bool showInstructions;

  @override
  State<ManualAdjustmentInterface> createState() =>
      _ManualAdjustmentInterfaceState();
}

class _ManualAdjustmentInterfaceState extends State<ManualAdjustmentInterface>
    with TickerProviderStateMixin {
  EdgeDetectionResult? _workingResult;
  int? _selectedCornerIndex;
  bool _hasChanges = false;
  late AnimationController _instructionAnimationController;
  late Animation<double> _instructionAnimation;

  @override
  void initState() {
    super.initState();
    _workingResult = widget.currentResult;
    
    _instructionAnimationController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    );
    _instructionAnimation = Tween<double>(
      begin: 0.5,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _instructionAnimationController,
      curve: Curves.easeInOut,
    ));
    
    // Set animation to middle value for predictable testing
    _instructionAnimationController.value = 0.75;
  }

  @override
  void dispose() {
    _instructionAnimationController.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(ManualAdjustmentInterface oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.currentResult != oldWidget.currentResult) {
      setState(() {
        _workingResult = widget.currentResult;
        _hasChanges = false;
        _selectedCornerIndex = null;
      });
    }
  }

  void _onCornerDrag(int cornerIndex, Offset globalPosition) {
    if (_workingResult == null) return;

    // Convert global position to normalized coordinates
    final RenderBox? renderBox = context.findRenderObject() as RenderBox?;
    if (renderBox == null) return;

    final localPosition = renderBox.globalToLocal(globalPosition);
    final normalizedPosition = Offset(
      (localPosition.dx / widget.viewSize.width).clamp(0.0, 1.0),
      (localPosition.dy / widget.viewSize.height).clamp(0.0, 1.0),
    );

    final updatedCorners = List<Point>.from(_workingResult!.corners);
    if (cornerIndex < updatedCorners.length) {
      updatedCorners[cornerIndex] = Point(
        normalizedPosition.dx,
        normalizedPosition.dy,
      );

      final updatedResult = EdgeDetectionResult(
        success: true,
        corners: updatedCorners,
        confidence: _calculateAdjustedConfidence(updatedCorners),
        processingTimeMs: _workingResult!.processingTimeMs,
      );

      setState(() {
        _workingResult = updatedResult;
        _hasChanges = true;
        _selectedCornerIndex = cornerIndex;
      });

      widget.onResultChanged?.call(updatedResult);
    }
  }

  void _onCornerTap(int cornerIndex) {
    setState(() {
      _selectedCornerIndex = cornerIndex == _selectedCornerIndex ? null : cornerIndex;
    });
  }

  double _calculateAdjustedConfidence(List<Point> corners) {
    if (corners.length != 4) return 0.6;

    // Calculate area to ensure reasonable rectangle size
    final topLeft = corners[0];
    final topRight = corners[1];
    final bottomRight = corners[2];
    final bottomLeft = corners[3];

    final width = (topRight.x - topLeft.x).abs();
    final height = (bottomLeft.y - topLeft.y).abs();
    final area = width * height;

    // Penalize very small or very large rectangles
    final areaScore = area < 0.1 ? 0.6 : (area > 0.8 ? 0.7 : 0.9);
    
    // Manual adjustments get at least 0.8 confidence
    return (areaScore + 0.8) / 2;
  }

  void _resetToAuto() {
    setState(() {
      _workingResult = widget.currentResult;
      _hasChanges = false;
      _selectedCornerIndex = null;
    });
    widget.onResetToAuto?.call();
  }

  void _confirmChanges() {
    if (_workingResult != null && widget.onConfirm != null) {
      widget.onConfirm!(_workingResult!);
    }
  }

  void _cancelChanges() {
    setState(() {
      _workingResult = widget.currentResult;
      _hasChanges = false;
      _selectedCornerIndex = null;
    });
    widget.onCancel?.call();
  }

  @override
  Widget build(BuildContext context) {
    if (_workingResult == null || !_workingResult!.success) {
      return _buildNoDetectionInterface();
    }

    return Column(
      children: [
        // Instructions
        if (widget.showInstructions) _buildInstructions(),
        
        // Main adjustment area
        Expanded(
          child: Stack(
            children: [
              // Corner handles
              ..._buildCornerHandles(),
              
              // Guidelines
              if (_selectedCornerIndex != null) _buildGuidelines(),
            ],
          ),
        ),
        
        // Control buttons
        _buildControlButtons(),
      ],
    );
  }

  Widget _buildNoDetectionInterface() {
    return Container(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.crop_free,
            size: 64,
            color: Colors.grey.shade400,
          ),
          const SizedBox(height: 16),
          Text(
            'No receipt detected',
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
              color: Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Try repositioning the camera to capture the full receipt',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Colors.grey.shade500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildInstructions() {
    return Container(
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.blue.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.blue.shade200),
      ),
      child: Row(
        children: [
          AnimatedBuilder(
            animation: _instructionAnimation,
            builder: (context, child) {
              return Transform.scale(
                scale: _instructionAnimation.value,
                child: Icon(
                  Icons.touch_app,
                  color: Colors.blue.shade600,
                  size: 24,
                ),
              );
            },
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              'Drag the corner handles to adjust the receipt boundaries',
              style: TextStyle(
                color: Colors.blue.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }

  List<Widget> _buildCornerHandles() {
    if (_workingResult?.corners.isEmpty ?? true) return [];

    return _workingResult!.corners.asMap().entries.map((entry) {
      final index = entry.key;
      final corner = entry.value;
      final isSelected = _selectedCornerIndex == index;
      
      final position = Offset(
        corner.x * widget.viewSize.width,
        corner.y * widget.viewSize.height,
      );

      return Positioned(
        left: position.dx - 16,
        top: position.dy - 16,
        child: GestureDetector(
          onTap: () => _onCornerTap(index),
          onPanUpdate: (details) => _onCornerDrag(index, details.globalPosition),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            width: isSelected ? 40 : 32,
            height: isSelected ? 40 : 32,
            decoration: BoxDecoration(
              color: isSelected ? Colors.blue : Colors.white,
              border: Border.all(
                color: isSelected ? Colors.blue.shade700 : Colors.blue.shade400,
                width: isSelected ? 3 : 2,
              ),
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withAlpha((0.3 * 255).round()),
                  blurRadius: isSelected ? 6 : 3,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Icon(
              Icons.drag_indicator,
              size: isSelected ? 20 : 16,
              color: isSelected ? Colors.white : Colors.blue.shade600,
            ),
          ),
        ),
      );
    }).toList();
  }

  Widget _buildGuidelines() {
    if (_selectedCornerIndex == null || _workingResult == null) {
      return const SizedBox.shrink();
    }

    final selectedCorner = _workingResult!.corners[_selectedCornerIndex!];
    final position = Offset(
      selectedCorner.x * widget.viewSize.width,
      selectedCorner.y * widget.viewSize.height,
    );

    return CustomPaint(
      size: widget.viewSize,
      painter: GuidelinesPainter(
        selectedPosition: position,
        viewSize: widget.viewSize,
      ),
    );
  }

  Widget _buildControlButtons() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Row(
        children: [
          // Reset button
          Expanded(
            child: OutlinedButton.icon(
              onPressed: _hasChanges ? _resetToAuto : null,
              icon: const Icon(Icons.refresh),
              label: const Text('Reset'),
            ),
          ),
          const SizedBox(width: 12),
          
          // Cancel button
          Expanded(
            child: OutlinedButton.icon(
              onPressed: widget.onCancel,
              icon: const Icon(Icons.close),
              label: const Text('Cancel'),
            ),
          ),
          const SizedBox(width: 12),
          
          // Confirm button
          Expanded(
            flex: 2,
            child: ElevatedButton.icon(
              onPressed: _workingResult?.success == true ? _confirmChanges : null,
              icon: const Icon(Icons.check),
              label: const Text('Confirm'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.green,
                foregroundColor: Colors.white,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// Custom painter for drawing guidelines during corner adjustment
class GuidelinesPainter extends CustomPainter {
  const GuidelinesPainter({
    required this.selectedPosition,
    required this.viewSize,
  });

  final Offset selectedPosition;
  final Size viewSize;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.blue.withAlpha((0.5 * 255).round())
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    // Draw horizontal guideline
    canvas.drawLine(
      Offset(0, selectedPosition.dy),
      Offset(size.width, selectedPosition.dy),
      paint,
    );

    // Draw vertical guideline
    canvas.drawLine(
      Offset(selectedPosition.dx, 0),
      Offset(selectedPosition.dx, size.height),
      paint,
    );

    // Draw grid lines for precision
    final gridPaint = Paint()
      ..color = Colors.blue.withAlpha((0.2 * 255).round())
      ..strokeWidth = 0.5
      ..style = PaintingStyle.stroke;

    const gridSpacing = 50.0;
    
    // Vertical grid lines
    for (double x = 0; x <= size.width; x += gridSpacing) {
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        gridPaint,
      );
    }
    
    // Horizontal grid lines
    for (double y = 0; y <= size.height; y += gridSpacing) {
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        gridPaint,
      );
    }
  }

  @override
  bool shouldRepaint(GuidelinesPainter oldDelegate) {
    return oldDelegate.selectedPosition != selectedPosition ||
           oldDelegate.viewSize != viewSize;
  }
}