# Receipt Organizer MVP - Comprehensive Implementation Plan

**Meta:**
- Project: Receipt Organizer
- Phase: MVP Development
- Target: Production-Ready Receipt Management Application
- Architecture: Cross-Platform (Next.js Web + React Native Mobile)
- Backend: Supabase (Database + Storage + Auth)
- UI Framework: Shadcn/UI (Web) + Gluestack UI (Mobile)

## Current State Analysis

**✅ Completed Infrastructure:**
- Supabase authentication with production database (xbadaalqaeszooyxuoac.supabase.co)
- Cross-platform user authentication (web + mobile sharing same database)
- Strong password validation (8+ chars, uppercase, lowercase, number, special char)
- Basic routing and navigation
- Environment configuration and deployment setup

**❌ Missing MVP Features:**
- Database schema for receipts, categories, tags
- File storage configuration for receipt images
- Receipt capture functionality (camera/file upload)
- OCR integration for data extraction
- Receipt management interface (CRUD operations)
- Search, filter, and categorization
- Export functionality (CSV, PDF)
- Dashboard with analytics
- Professional UI/UX design

## Phase 1: Database Foundation & Storage

### 1.1 Database Schema Implementation

**Priority:** Critical
**Estimated Time:** 4-6 hours

```sql
-- Receipts table with comprehensive metadata
CREATE TABLE receipts (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  -- Receipt Metadata
  receipt_date DATE NOT NULL,
  vendor_name VARCHAR(255) NOT NULL,
  total_amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  tax_amount DECIMAL(10,2),
  tip_amount DECIMAL(10,2),

  -- Categorization
  category_id UUID REFERENCES categories(id),
  subcategory VARCHAR(100),
  payment_method VARCHAR(50), -- cash, card, digital

  -- OCR and Processing
  ocr_confidence DECIMAL(5,2), -- 0.00 to 100.00
  ocr_raw_text TEXT,
  is_processed BOOLEAN DEFAULT FALSE,
  needs_review BOOLEAN DEFAULT FALSE,

  -- File References
  image_url TEXT, -- Supabase Storage URL
  thumbnail_url TEXT, -- Optimized thumbnail

  -- Business Fields
  business_purpose TEXT,
  notes TEXT,
  tags TEXT[], -- Array of tags for flexible categorization

  -- Indexing for performance
  CONSTRAINT positive_amount CHECK (total_amount >= 0),
  CONSTRAINT valid_currency CHECK (currency ~ '^[A-Z]{3}$')
);

-- Categories for organization
CREATE TABLE categories (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  name VARCHAR(100) NOT NULL,
  color VARCHAR(7), -- Hex color code
  icon VARCHAR(50), -- Icon identifier
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  UNIQUE(user_id, name)
);

-- Performance indexes
CREATE INDEX idx_receipts_user_date ON receipts(user_id, receipt_date DESC);
CREATE INDEX idx_receipts_vendor ON receipts(user_id, vendor_name);
CREATE INDEX idx_receipts_category ON receipts(category_id);
CREATE INDEX idx_receipts_tags ON receipts USING GIN(tags);
CREATE INDEX idx_receipts_amount ON receipts(user_id, total_amount);

-- Row Level Security policies
ALTER TABLE receipts ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only access their own receipts" ON receipts
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can only access their own categories" ON categories
  FOR ALL USING (auth.uid() = user_id);

-- Auto-update timestamp trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language plpgsql;

CREATE TRIGGER update_receipts_updated_at
  BEFORE UPDATE ON receipts
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
```

### 1.2 Storage Configuration

**Priority:** Critical
**Estimated Time:** 2-3 hours

```sql
-- Storage bucket for receipt images
INSERT INTO storage.buckets (id, name, public)
VALUES ('receipts', 'receipts', false);

-- Storage policies for receipt images
CREATE POLICY "Users can upload their own receipt images" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'receipts' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Users can view their own receipt images" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'receipts' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Users can update their own receipt images" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'receipts' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Users can delete their own receipt images" ON storage.objects
  FOR DELETE USING (
    bucket_id = 'receipts' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );
```

### 1.3 Default Categories Seeding

**Priority:** Medium
**Estimated Time:** 1 hour

```sql
-- Function to create default categories for new users
CREATE OR REPLACE FUNCTION create_default_categories(user_uuid UUID)
RETURNS void AS $$
BEGIN
  INSERT INTO categories (user_id, name, color, icon) VALUES
    (user_uuid, 'Business Meals', '#3B82F6', 'utensils'),
    (user_uuid, 'Travel & Transportation', '#10B981', 'plane'),
    (user_uuid, 'Office Supplies', '#8B5CF6', 'briefcase'),
    (user_uuid, 'Software & Subscriptions', '#F59E0B', 'laptop'),
    (user_uuid, 'Marketing & Advertising', '#EF4444', 'megaphone'),
    (user_uuid, 'Professional Services', '#6B7280', 'user-tie'),
    (user_uuid, 'Equipment & Hardware', '#9333EA', 'wrench'),
    (user_uuid, 'Utilities', '#14B8A6', 'zap'),
    (user_uuid, 'Other', '#64748B', 'folder');
END;
$$ LANGUAGE plpgsql;

-- Trigger to create default categories for new users
CREATE OR REPLACE FUNCTION handle_new_user_categories()
RETURNS trigger AS $$
BEGIN
  PERFORM create_default_categories(NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created_categories
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE handle_new_user_categories();
```

## Phase 2: Core Receipt Capture Implementation

### 2.1 File Upload Service (Web & Mobile)

**Priority:** Critical
**Estimated Time:** 8-10 hours

**Web Implementation (Next.js):**
```typescript
// lib/services/receipt-upload.ts
import { createClient } from '@/lib/supabase/client'

export interface ReceiptUploadResult {
  success: boolean
  imageUrl?: string
  thumbnailUrl?: string
  error?: string
}

export class ReceiptUploadService {
  private supabase = createClient()

  async uploadReceiptImage(
    file: File,
    userId: string
  ): Promise<ReceiptUploadResult> {
    try {
      // Validate file
      if (!this.isValidImageFile(file)) {
        return { success: false, error: 'Invalid file type. Please upload a valid image.' }
      }

      if (file.size > 10 * 1024 * 1024) { // 10MB limit
        return { success: false, error: 'File size too large. Maximum 10MB allowed.' }
      }

      // Generate unique filename
      const fileExt = file.name.split('.').pop()
      const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`
      const filePath = `${userId}/receipts/${fileName}`

      // Upload original image
      const { data: uploadData, error: uploadError } = await this.supabase.storage
        .from('receipts')
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false
        })

      if (uploadError) throw uploadError

      // Get public URL
      const { data: { publicUrl } } = this.supabase.storage
        .from('receipts')
        .getPublicUrl(filePath)

      // Create and upload thumbnail
      const thumbnailFile = await this.createThumbnail(file)
      const thumbnailPath = `${userId}/thumbnails/${fileName}`

      await this.supabase.storage
        .from('receipts')
        .upload(thumbnailPath, thumbnailFile)

      const { data: { publicUrl: thumbnailUrl } } = this.supabase.storage
        .from('receipts')
        .getPublicUrl(thumbnailPath)

      return {
        success: true,
        imageUrl: publicUrl,
        thumbnailUrl
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Upload failed'
      }
    }
  }

  private async createThumbnail(file: File): Promise<File> {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      const img = new Image()

      img.onload = () => {
        // Calculate dimensions for 300px max width/height
        const maxSize = 300
        let { width, height } = img

        if (width > height && width > maxSize) {
          height = (height * maxSize) / width
          width = maxSize
        } else if (height > maxSize) {
          width = (width * maxSize) / height
          height = maxSize
        }

        canvas.width = width
        canvas.height = height
        ctx?.drawImage(img, 0, 0, width, height)

        canvas.toBlob((blob) => {
          if (blob) {
            const thumbnailFile = new File([blob], file.name, { type: 'image/jpeg' })
            resolve(thumbnailFile)
          } else {
            reject(new Error('Failed to create thumbnail'))
          }
        }, 'image/jpeg', 0.8)
      }

      img.onerror = () => reject(new Error('Failed to load image'))
      img.src = URL.createObjectURL(file)
    })
  }

  private isValidImageFile(file: File): boolean {
    const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/heic']
    return validTypes.includes(file.type)
  }
}
```

**Mobile Implementation (React Native):**
```typescript
// lib/services/receipt-upload.native.ts
import { supabase } from '../supabase'
import * as ImagePicker from 'expo-image-picker'
import * as ImageManipulator from 'expo-image-manipulator'

export class ReceiptUploadService {
  async captureReceiptFromCamera(): Promise<ReceiptUploadResult> {
    const { status } = await ImagePicker.requestCameraPermissionsAsync()
    if (status !== 'granted') {
      return { success: false, error: 'Camera permission required' }
    }

    const result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
      exif: false
    })

    if (!result.canceled && result.assets[0]) {
      return this.uploadImageAsset(result.assets[0])
    }

    return { success: false, error: 'Capture cancelled' }
  }

  async pickReceiptFromLibrary(): Promise<ReceiptUploadResult> {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
      exif: false
    })

    if (!result.canceled && result.assets[0]) {
      return this.uploadImageAsset(result.assets[0])
    }

    return { success: false, error: 'Selection cancelled' }
  }

  private async uploadImageAsset(asset: ImagePicker.ImagePickerAsset): Promise<ReceiptUploadResult> {
    try {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('User not authenticated')

      // Compress and resize image
      const compressedImage = await ImageManipulator.manipulateAsync(
        asset.uri,
        [
          { resize: { width: 1200 } }, // Max width 1200px
        ],
        {
          compress: 0.8,
          format: ImageManipulator.SaveFormat.JPEG,
        }
      )

      // Create thumbnail
      const thumbnail = await ImageManipulator.manipulateAsync(
        asset.uri,
        [{ resize: { width: 300 } }],
        {
          compress: 0.7,
          format: ImageManipulator.SaveFormat.JPEG,
        }
      )

      // Convert to FormData for upload
      const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.jpg`
      const filePath = `${user.id}/receipts/${fileName}`
      const thumbnailPath = `${user.id}/thumbnails/${fileName}`

      // Upload main image
      const formData = new FormData()
      formData.append('file', {
        uri: compressedImage.uri,
        name: fileName,
        type: 'image/jpeg'
      } as any)

      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('receipts')
        .upload(filePath, formData, {
          cacheControl: '3600',
          upsert: false
        })

      if (uploadError) throw uploadError

      // Upload thumbnail
      const thumbnailFormData = new FormData()
      thumbnailFormData.append('file', {
        uri: thumbnail.uri,
        name: `thumb_${fileName}`,
        type: 'image/jpeg'
      } as any)

      await supabase.storage
        .from('receipts')
        .upload(thumbnailPath, thumbnailFormData)

      // Get public URLs
      const { data: { publicUrl } } = supabase.storage
        .from('receipts')
        .getPublicUrl(filePath)

      const { data: { publicUrl: thumbnailUrl } } = supabase.storage
        .from('receipts')
        .getPublicUrl(thumbnailPath)

      return {
        success: true,
        imageUrl: publicUrl,
        thumbnailUrl
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Upload failed'
      }
    }
  }
}
```

### 2.2 Receipt Capture Interface

**Priority:** Critical
**Estimated Time:** 12-15 hours

**Web Component (Shadcn/UI):**
```typescript
// components/receipts/receipt-capture.tsx
'use client'

import { useState, useRef } from 'react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { Camera, Upload, X, Check, AlertCircle } from 'lucide-react'
import { ReceiptUploadService } from '@/lib/services/receipt-upload'

interface ReceiptCaptureProps {
  onSuccess?: (receiptId: string) => void
  onCancel?: () => void
}

export function ReceiptCapture({ onSuccess, onCancel }: ReceiptCaptureProps) {
  const [isUploading, setIsUploading] = useState(false)
  const [uploadedImage, setUploadedImage] = useState<string | null>(null)
  const [formData, setFormData] = useState({
    vendor_name: '',
    total_amount: '',
    receipt_date: new Date().toISOString().split('T')[0],
    category_id: '',
    payment_method: 'card',
    notes: '',
    business_purpose: ''
  })

  const fileInputRef = useRef<HTMLInputElement>(null)
  const uploadService = new ReceiptUploadService()

  const handleFileUpload = async (file: File) => {
    setIsUploading(true)

    try {
      const result = await uploadService.uploadReceiptImage(file, user.id)

      if (result.success) {
        setUploadedImage(result.imageUrl!)
        // TODO: Trigger OCR processing
        await processReceiptWithOCR(result.imageUrl!)
      } else {
        // Show error
        console.error(result.error)
      }
    } catch (error) {
      console.error('Upload failed:', error)
    } finally {
      setIsUploading(false)
    }
  }

  const processReceiptWithOCR = async (imageUrl: string) => {
    // TODO: Implement OCR integration
    // This will extract text and attempt to parse vendor, amount, date
  }

  const handleSubmit = async () => {
    if (!uploadedImage) return

    try {
      const { data, error } = await supabase
        .from('receipts')
        .insert([{
          ...formData,
          image_url: uploadedImage,
          total_amount: parseFloat(formData.total_amount),
          user_id: user.id
        }])
        .select()
        .single()

      if (error) throw error

      onSuccess?.(data.id)
    } catch (error) {
      console.error('Failed to save receipt:', error)
    }
  }

  return (
    <Card className="w-full max-w-2xl">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Camera className="h-5 w-5" />
          Add New Receipt
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Image Upload Area */}
        <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
          {uploadedImage ? (
            <div className="relative">
              <img
                src={uploadedImage}
                alt="Receipt"
                className="w-full max-h-64 object-contain rounded"
              />
              <Button
                variant="destructive"
                size="sm"
                className="absolute top-2 right-2"
                onClick={() => setUploadedImage(null)}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          ) : (
            <div className="text-center">
              <div className="flex justify-center gap-4 mb-4">
                <Button
                  variant="outline"
                  onClick={() => fileInputRef.current?.click()}
                  disabled={isUploading}
                >
                  <Upload className="h-4 w-4 mr-2" />
                  Upload Image
                </Button>
              </div>
              <p className="text-sm text-gray-500">
                Upload a photo of your receipt (JPG, PNG, WebP, HEIC)
              </p>
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                className="hidden"
                onChange={(e) => {
                  const file = e.target.files?.[0]
                  if (file) handleFileUpload(file)
                }}
              />
            </div>
          )}
        </div>

        {/* Form Fields */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <Label htmlFor="vendor">Vendor Name *</Label>
            <Input
              id="vendor"
              value={formData.vendor_name}
              onChange={(e) => setFormData({ ...formData, vendor_name: e.target.value })}
              placeholder="e.g., Starbucks, Amazon, etc."
            />
          </div>

          <div>
            <Label htmlFor="amount">Total Amount *</Label>
            <Input
              id="amount"
              type="number"
              step="0.01"
              value={formData.total_amount}
              onChange={(e) => setFormData({ ...formData, total_amount: e.target.value })}
              placeholder="0.00"
            />
          </div>

          <div>
            <Label htmlFor="date">Receipt Date *</Label>
            <Input
              id="date"
              type="date"
              value={formData.receipt_date}
              onChange={(e) => setFormData({ ...formData, receipt_date: e.target.value })}
            />
          </div>

          <div>
            <Label htmlFor="category">Category</Label>
            <Select
              value={formData.category_id}
              onValueChange={(value) => setFormData({ ...formData, category_id: value })}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select category" />
              </SelectTrigger>
              <SelectContent>
                {/* Categories will be loaded from database */}
                <SelectItem value="business-meals">Business Meals</SelectItem>
                <SelectItem value="travel">Travel & Transportation</SelectItem>
                <SelectItem value="office">Office Supplies</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label htmlFor="payment">Payment Method</Label>
            <Select
              value={formData.payment_method}
              onValueChange={(value) => setFormData({ ...formData, payment_method: value })}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="cash">Cash</SelectItem>
                <SelectItem value="card">Credit/Debit Card</SelectItem>
                <SelectItem value="digital">Digital Payment</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="md:col-span-2">
            <Label htmlFor="purpose">Business Purpose</Label>
            <Textarea
              id="purpose"
              value={formData.business_purpose}
              onChange={(e) => setFormData({ ...formData, business_purpose: e.target.value })}
              placeholder="Brief description of business purpose..."
            />
          </div>

          <div className="md:col-span-2">
            <Label htmlFor="notes">Notes</Label>
            <Textarea
              id="notes"
              value={formData.notes}
              onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
              placeholder="Additional notes..."
            />
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-between">
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={!uploadedImage || !formData.vendor_name || !formData.total_amount}
          >
            <Check className="h-4 w-4 mr-2" />
            Save Receipt
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

**Mobile Component (Gluestack UI):**
```typescript
// app/receipts/capture.tsx
import { useState } from 'react'
import { Alert } from 'react-native'
import {
  VStack, HStack, Button, ButtonText, Input, InputField,
  Card, Heading, Text, Select, SelectTrigger, SelectInput,
  SelectIcon, SelectPortal, SelectBackdrop, SelectContent,
  SelectDragIndicatorWrapper, SelectDragIndicator, SelectItem,
  Textarea, TextareaInput, Image, Box
} from '@gluestack-ui/themed'
import { Camera, Upload, Check, X } from 'lucide-react-native'
import { ReceiptUploadService } from '../../lib/services/receipt-upload'

export default function ReceiptCaptureScreen() {
  const [isUploading, setIsUploading] = useState(false)
  const [uploadedImage, setUploadedImage] = useState<string | null>(null)
  const [formData, setFormData] = useState({
    vendor_name: '',
    total_amount: '',
    receipt_date: new Date().toISOString().split('T')[0],
    category_id: '',
    payment_method: 'card',
    notes: '',
    business_purpose: ''
  })

  const uploadService = new ReceiptUploadService()

  const handleCameraCapture = async () => {
    setIsUploading(true)
    try {
      const result = await uploadService.captureReceiptFromCamera()
      if (result.success) {
        setUploadedImage(result.imageUrl!)
        // Process with OCR
      } else {
        Alert.alert('Error', result.error || 'Failed to capture image')
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to access camera')
    } finally {
      setIsUploading(false)
    }
  }

  const handleLibraryPick = async () => {
    setIsUploading(true)
    try {
      const result = await uploadService.pickReceiptFromLibrary()
      if (result.success) {
        setUploadedImage(result.imageUrl!)
        // Process with OCR
      } else {
        Alert.alert('Error', result.error || 'Failed to select image')
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to access photo library')
    } finally {
      setIsUploading(false)
    }
  }

  return (
    <VStack space="lg" className="flex-1 p-4 bg-background">
      <Card className="p-4">
        <VStack space="lg">
          <Heading size="lg">Add New Receipt</Heading>

          {/* Image Upload Section */}
          {uploadedImage ? (
            <Box className="relative">
              <Image
                source={{ uri: uploadedImage }}
                className="w-full h-48 rounded-lg"
                alt="Receipt"
                resizeMode="contain"
              />
              <Button
                size="sm"
                variant="solid"
                action="negative"
                className="absolute top-2 right-2"
                onPress={() => setUploadedImage(null)}
              >
                <X size={16} />
              </Button>
            </Box>
          ) : (
            <VStack space="md" className="border-2 border-dashed border-border rounded-lg p-6">
              <HStack space="md" className="justify-center">
                <Button
                  variant="outline"
                  onPress={handleCameraCapture}
                  isDisabled={isUploading}
                >
                  <Camera size={16} className="mr-2" />
                  <ButtonText>Camera</ButtonText>
                </Button>

                <Button
                  variant="outline"
                  onPress={handleLibraryPick}
                  isDisabled={isUploading}
                >
                  <Upload size={16} className="mr-2" />
                  <ButtonText>Gallery</ButtonText>
                </Button>
              </HStack>
              <Text className="text-center text-muted-foreground text-sm">
                Capture or select a receipt image
              </Text>
            </VStack>
          )}

          {/* Form Fields */}
          <VStack space="md">
            <VStack space="xs">
              <Text className="font-medium">Vendor Name *</Text>
              <Input variant="outline">
                <InputField
                  placeholder="e.g., Starbucks, Amazon"
                  value={formData.vendor_name}
                  onChangeText={(text) => setFormData({ ...formData, vendor_name: text })}
                />
              </Input>
            </VStack>

            <HStack space="md">
              <VStack space="xs" className="flex-1">
                <Text className="font-medium">Amount *</Text>
                <Input variant="outline">
                  <InputField
                    placeholder="0.00"
                    keyboardType="decimal-pad"
                    value={formData.total_amount}
                    onChangeText={(text) => setFormData({ ...formData, total_amount: text })}
                  />
                </Input>
              </VStack>

              <VStack space="xs" className="flex-1">
                <Text className="font-medium">Date *</Text>
                <Input variant="outline">
                  <InputField
                    value={formData.receipt_date}
                    onChangeText={(text) => setFormData({ ...formData, receipt_date: text })}
                  />
                </Input>
              </VStack>
            </HStack>

            <VStack space="xs">
              <Text className="font-medium">Category</Text>
              <Select>
                <SelectTrigger variant="outline">
                  <SelectInput placeholder="Select category" />
                  <SelectIcon className="mr-3" />
                </SelectTrigger>
                <SelectPortal>
                  <SelectBackdrop />
                  <SelectContent>
                    <SelectDragIndicatorWrapper>
                      <SelectDragIndicator />
                    </SelectDragIndicatorWrapper>
                    <SelectItem label="Business Meals" value="business-meals" />
                    <SelectItem label="Travel & Transportation" value="travel" />
                    <SelectItem label="Office Supplies" value="office" />
                  </SelectContent>
                </SelectPortal>
              </Select>
            </VStack>

            <VStack space="xs">
              <Text className="font-medium">Business Purpose</Text>
              <Textarea>
                <TextareaInput
                  placeholder="Brief description..."
                  value={formData.business_purpose}
                  onChangeText={(text) => setFormData({ ...formData, business_purpose: text })}
                />
              </Textarea>
            </VStack>
          </VStack>

          {/* Action Buttons */}
          <HStack space="md" className="justify-between">
            <Button variant="outline" className="flex-1">
              <ButtonText>Cancel</ButtonText>
            </Button>
            <Button
              className="flex-1"
              isDisabled={!uploadedImage || !formData.vendor_name || !formData.total_amount}
            >
              <Check size={16} className="mr-2" />
              <ButtonText>Save Receipt</ButtonText>
            </Button>
          </HStack>
        </VStack>
      </Card>
    </VStack>
  )
}
```

## Phase 3: OCR Integration & Data Extraction

### 3.1 OCR Service Implementation

**Priority:** High
**Estimated Time:** 10-12 hours

**OCR Integration Options:**
1. **Google Vision API** (Recommended for accuracy)
2. **Tesseract.js** (Free, client-side option)
3. **AWS Textract** (Specialized for receipts)

```typescript
// lib/services/ocr-service.ts
export interface ReceiptOCRData {
  vendor_name?: string
  total_amount?: number
  receipt_date?: string
  tax_amount?: number
  payment_method?: string
  confidence: number
  raw_text: string
}

export class OCRService {
  private apiKey: string

  constructor(apiKey: string) {
    this.apiKey = apiKey
  }

  async processReceipt(imageUrl: string): Promise<ReceiptOCRData> {
    try {
      // Call Google Vision API or chosen OCR service
      const response = await fetch('https://vision.googleapis.com/v1/images:annotate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          requests: [{
            image: { source: { imageUri: imageUrl } },
            features: [
              { type: 'TEXT_DETECTION' },
              { type: 'DOCUMENT_TEXT_DETECTION' }
            ]
          }]
        })
      })

      const data = await response.json()
      const extractedText = data.responses[0].fullTextAnnotation?.text || ''

      // Parse extracted text to identify receipt components
      return this.parseReceiptText(extractedText)
    } catch (error) {
      return {
        confidence: 0,
        raw_text: '',
      }
    }
  }

  private parseReceiptText(text: string): ReceiptOCRData {
    const lines = text.split('\n').filter(line => line.trim())

    // Patterns for common receipt elements
    const totalPattern = /(?:total|amount|sum)[:\s]*\$?(\d+\.?\d*)/i
    const vendorPattern = /^([A-Za-z\s&'.-]{2,50})/
    const datePattern = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/
    const taxPattern = /(?:tax|hst|gst|vat)[:\s]*\$?(\d+\.?\d*)/i

    let vendor_name = ''
    let total_amount = 0
    let receipt_date = ''
    let tax_amount = 0

    // Extract vendor (usually first meaningful line)
    for (const line of lines) {
      const vendorMatch = line.match(vendorPattern)
      if (vendorMatch && !line.match(/\d{4}/) && !line.includes('$')) {
        vendor_name = vendorMatch[1].trim()
        break
      }
    }

    // Extract total amount
    for (const line of lines) {
      const totalMatch = line.match(totalPattern)
      if (totalMatch) {
        total_amount = parseFloat(totalMatch[1])
        break
      }
    }

    // Extract date
    for (const line of lines) {
      const dateMatch = line.match(datePattern)
      if (dateMatch) {
        const [, month, day, year] = dateMatch
        receipt_date = `${year.length === 2 ? '20' + year : year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`
        break
      }
    }

    // Extract tax
    for (const line of lines) {
      const taxMatch = line.match(taxPattern)
      if (taxMatch) {
        tax_amount = parseFloat(taxMatch[1])
        break
      }
    }

    // Calculate confidence based on what we found
    let confidence = 0
    if (vendor_name) confidence += 30
    if (total_amount > 0) confidence += 40
    if (receipt_date) confidence += 20
    if (tax_amount > 0) confidence += 10

    return {
      vendor_name: vendor_name || undefined,
      total_amount: total_amount || undefined,
      receipt_date: receipt_date || undefined,
      tax_amount: tax_amount || undefined,
      confidence,
      raw_text: text
    }
  }
}
```

### 3.2 OCR Integration with Upload Flow

**Priority:** High
**Estimated Time:** 4-6 hours

```typescript
// Enhance the upload service to include OCR processing
export class ReceiptUploadService {
  private ocrService = new OCRService(process.env.GOOGLE_VISION_API_KEY!)

  async uploadReceiptImage(
    file: File,
    userId: string
  ): Promise<ReceiptUploadResult & { ocrData?: ReceiptOCRData }> {
    const uploadResult = await super.uploadReceiptImage(file, userId)

    if (uploadResult.success && uploadResult.imageUrl) {
      // Process with OCR
      const ocrData = await this.ocrService.processReceipt(uploadResult.imageUrl)

      return {
        ...uploadResult,
        ocrData
      }
    }

    return uploadResult
  }
}
```

## Phase 4: Receipt Management Interface

### 4.1 Receipt List View

**Priority:** Critical
**Estimated Time:** 15-18 hours

**Web Component:**
```typescript
// components/receipts/receipts-list.tsx
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Badge } from '@/components/ui/badge'
import {
  Table, TableBody, TableCell, TableHead,
  TableHeader, TableRow
} from '@/components/ui/table'
import {
  DropdownMenu, DropdownMenuContent, DropdownMenuItem,
  DropdownMenuTrigger, DropdownMenuSeparator
} from '@/components/ui/dropdown-menu'
import {
  Search, Filter, MoreVertical, Edit, Trash,
  Eye, Download, Calendar, DollarSign
} from 'lucide-react'

interface Receipt {
  id: string
  vendor_name: string
  total_amount: number
  receipt_date: string
  category_name?: string
  payment_method: string
  image_url: string
  thumbnail_url?: string
  ocr_confidence?: number
  needs_review: boolean
  tags: string[]
}

export function ReceiptsList() {
  const [receipts, setReceipts] = useState<Receipt[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [selectedCategory, setSelectedCategory] = useState<string>('')
  const [sortBy, setSortBy] = useState<'date' | 'amount' | 'vendor'>('date')
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc')

  useEffect(() => {
    loadReceipts()
  }, [searchTerm, selectedCategory, sortBy, sortOrder])

  const loadReceipts = async () => {
    setLoading(true)
    try {
      let query = supabase
        .from('receipts')
        .select(`
          *,
          categories (name)
        `)

      // Apply search filter
      if (searchTerm) {
        query = query.or(`vendor_name.ilike.%${searchTerm}%,notes.ilike.%${searchTerm}%`)
      }

      // Apply category filter
      if (selectedCategory) {
        query = query.eq('category_id', selectedCategory)
      }

      // Apply sorting
      const column = sortBy === 'date' ? 'receipt_date' :
                    sortBy === 'amount' ? 'total_amount' : 'vendor_name'
      query = query.order(column, { ascending: sortOrder === 'asc' })

      const { data, error } = await query

      if (error) throw error
      setReceipts(data || [])
    } catch (error) {
      console.error('Failed to load receipts:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount)
  }

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    })
  }

  const handleReceiptAction = async (action: string, receiptId: string) => {
    switch (action) {
      case 'view':
        // Open receipt details modal
        break
      case 'edit':
        // Open edit form
        break
      case 'delete':
        if (confirm('Are you sure you want to delete this receipt?')) {
          await deleteReceipt(receiptId)
        }
        break
      case 'download':
        // Download receipt image
        break
    }
  }

  const deleteReceipt = async (receiptId: string) => {
    try {
      const { error } = await supabase
        .from('receipts')
        .delete()
        .eq('id', receiptId)

      if (error) throw error

      setReceipts(receipts.filter(r => r.id !== receiptId))
    } catch (error) {
      console.error('Failed to delete receipt:', error)
    }
  }

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="text-center">Loading receipts...</div>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      {/* Filters and Search */}
      <Card>
        <CardContent className="p-4">
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search receipts..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
              />
            </div>

            <div className="flex gap-2">
              <Button variant="outline" size="sm">
                <Filter className="h-4 w-4 mr-2" />
                Filter
              </Button>

              <Button variant="outline" size="sm">
                <Calendar className="h-4 w-4 mr-2" />
                Date Range
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Receipts Table */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Receipts ({receipts.length})</span>
            <div className="text-sm text-muted-foreground">
              Total: {formatCurrency(receipts.reduce((sum, r) => sum + r.total_amount, 0))}
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-16">Image</TableHead>
                <TableHead
                  className="cursor-pointer"
                  onClick={() => {
                    if (sortBy === 'vendor') {
                      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
                    } else {
                      setSortBy('vendor')
                      setSortOrder('asc')
                    }
                  }}
                >
                  Vendor
                </TableHead>
                <TableHead
                  className="cursor-pointer"
                  onClick={() => {
                    if (sortBy === 'amount') {
                      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
                    } else {
                      setSortBy('amount')
                      setSortOrder('desc')
                    }
                  }}
                >
                  Amount
                </TableHead>
                <TableHead
                  className="cursor-pointer"
                  onClick={() => {
                    if (sortBy === 'date') {
                      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
                    } else {
                      setSortBy('date')
                      setSortOrder('desc')
                    }
                  }}
                >
                  Date
                </TableHead>
                <TableHead>Category</TableHead>
                <TableHead>Status</TableHead>
                <TableHead className="w-16">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {receipts.map((receipt) => (
                <TableRow key={receipt.id}>
                  <TableCell>
                    {receipt.thumbnail_url ? (
                      <img
                        src={receipt.thumbnail_url}
                        alt="Receipt"
                        className="w-10 h-10 object-cover rounded"
                      />
                    ) : (
                      <div className="w-10 h-10 bg-gray-100 rounded flex items-center justify-center">
                        <Eye className="h-4 w-4 text-gray-400" />
                      </div>
                    )}
                  </TableCell>

                  <TableCell className="font-medium">
                    {receipt.vendor_name}
                  </TableCell>

                  <TableCell>
                    {formatCurrency(receipt.total_amount)}
                  </TableCell>

                  <TableCell>
                    {formatDate(receipt.receipt_date)}
                  </TableCell>

                  <TableCell>
                    {receipt.category_name && (
                      <Badge variant="secondary">
                        {receipt.category_name}
                      </Badge>
                    )}
                  </TableCell>

                  <TableCell>
                    <div className="flex gap-1">
                      {receipt.needs_review && (
                        <Badge variant="destructive" className="text-xs">
                          Review
                        </Badge>
                      )}
                      {receipt.ocr_confidence && receipt.ocr_confidence < 50 && (
                        <Badge variant="outline" className="text-xs">
                          Low Confidence
                        </Badge>
                      )}
                    </div>
                  </TableCell>

                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="sm">
                          <MoreVertical className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleReceiptAction('view', receipt.id)}>
                          <Eye className="h-4 w-4 mr-2" />
                          View
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleReceiptAction('edit', receipt.id)}>
                          <Edit className="h-4 w-4 mr-2" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleReceiptAction('download', receipt.id)}>
                          <Download className="h-4 w-4 mr-2" />
                          Download
                        </DropdownMenuItem>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem
                          onClick={() => handleReceiptAction('delete', receipt.id)}
                          className="text-red-600"
                        >
                          <Trash className="h-4 w-4 mr-2" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>

          {receipts.length === 0 && (
            <div className="text-center py-8 text-muted-foreground">
              No receipts found. Add your first receipt to get started!
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

### 4.2 Dashboard with Analytics

**Priority:** High
**Estimated Time:** 10-12 hours

```typescript
// components/dashboard/analytics-dashboard.tsx
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer,
  PieChart, Pie, Cell, LineChart, Line
} from 'recharts'
import {
  DollarSign, Receipt, TrendingUp, Calendar,
  CreditCard, FileText, AlertCircle, CheckCircle
} from 'lucide-react'

interface DashboardStats {
  totalExpenses: number
  receiptCount: number
  thisMonthExpenses: number
  averageExpense: number
  categoryBreakdown: { name: string; value: number; color: string }[]
  monthlyTrends: { month: string; amount: number }[]
  paymentMethodBreakdown: { method: string; count: number }[]
  recentReceipts: Array<{
    id: string
    vendor_name: string
    total_amount: number
    receipt_date: string
    category_name?: string
  }>
}

export function AnalyticsDashboard() {
  const [stats, setStats] = useState<DashboardStats | null>(null)
  const [loading, setLoading] = useState(true)
  const [dateRange, setDateRange] = useState('30') // days

  useEffect(() => {
    loadDashboardStats()
  }, [dateRange])

  const loadDashboardStats = async () => {
    setLoading(true)
    try {
      const endDate = new Date()
      const startDate = new Date()
      startDate.setDate(startDate.getDate() - parseInt(dateRange))

      // Fetch all receipts in date range
      const { data: receipts, error } = await supabase
        .from('receipts')
        .select(`
          *,
          categories (name, color)
        `)
        .gte('receipt_date', startDate.toISOString().split('T')[0])
        .lte('receipt_date', endDate.toISOString().split('T')[0])
        .order('receipt_date', { ascending: false })

      if (error) throw error

      // Calculate statistics
      const totalExpenses = receipts?.reduce((sum, r) => sum + r.total_amount, 0) || 0
      const receiptCount = receipts?.length || 0

      // This month expenses
      const thisMonthStart = new Date(endDate.getFullYear(), endDate.getMonth(), 1)
      const thisMonthExpenses = receipts
        ?.filter(r => new Date(r.receipt_date) >= thisMonthStart)
        .reduce((sum, r) => sum + r.total_amount, 0) || 0

      const averageExpense = receiptCount > 0 ? totalExpenses / receiptCount : 0

      // Category breakdown
      const categoryMap = new Map<string, { amount: number; color: string }>()
      receipts?.forEach(receipt => {
        const categoryName = receipt.categories?.name || 'Uncategorized'
        const color = receipt.categories?.color || '#64748B'
        if (categoryMap.has(categoryName)) {
          categoryMap.get(categoryName)!.amount += receipt.total_amount
        } else {
          categoryMap.set(categoryName, { amount: receipt.total_amount, color })
        }
      })

      const categoryBreakdown = Array.from(categoryMap.entries()).map(([name, data]) => ({
        name,
        value: data.amount,
        color: data.color
      }))

      // Monthly trends (last 6 months)
      const monthlyMap = new Map<string, number>()
      const sixMonthsAgo = new Date()
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6)

      receipts?.forEach(receipt => {
        const date = new Date(receipt.receipt_date)
        if (date >= sixMonthsAgo) {
          const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
          monthlyMap.set(monthKey, (monthlyMap.get(monthKey) || 0) + receipt.total_amount)
        }
      })

      const monthlyTrends = Array.from(monthlyMap.entries()).map(([month, amount]) => ({
        month,
        amount
      }))

      // Payment method breakdown
      const paymentMap = new Map<string, number>()
      receipts?.forEach(receipt => {
        const method = receipt.payment_method || 'Unknown'
        paymentMap.set(method, (paymentMap.get(method) || 0) + 1)
      })

      const paymentMethodBreakdown = Array.from(paymentMap.entries()).map(([method, count]) => ({
        method,
        count
      }))

      setStats({
        totalExpenses,
        receiptCount,
        thisMonthExpenses,
        averageExpense,
        categoryBreakdown,
        monthlyTrends,
        paymentMethodBreakdown,
        recentReceipts: receipts?.slice(0, 5) || []
      })
    } catch (error) {
      console.error('Failed to load dashboard stats:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount)
  }

  if (loading || !stats) {
    return <div className="text-center p-8">Loading dashboard...</div>
  }

  return (
    <div className="space-y-6">
      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Total Expenses</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{formatCurrency(stats.totalExpenses)}</div>
            <p className="text-xs text-muted-foreground">
              Last {dateRange} days
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Total Receipts</CardTitle>
            <Receipt className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.receiptCount}</div>
            <p className="text-xs text-muted-foreground">
              {stats.receiptCount > 0 ? `Avg: ${formatCurrency(stats.averageExpense)}` : 'No receipts yet'}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">This Month</CardTitle>
            <Calendar className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{formatCurrency(stats.thisMonthExpenses)}</div>
            <p className="text-xs text-muted-foreground">
              {new Date().toLocaleDateString('en-US', { month: 'long' })}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Average Receipt</CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{formatCurrency(stats.averageExpense)}</div>
            <p className="text-xs text-muted-foreground">
              Per receipt
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Charts Row */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Category Breakdown */}
        <Card>
          <CardHeader>
            <CardTitle>Expenses by Category</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={stats.categoryBreakdown}
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#8884d8"
                  dataKey="value"
                  label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                >
                  {stats.categoryBreakdown.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
                <Tooltip formatter={(value) => formatCurrency(value as number)} />
              </PieChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        {/* Monthly Trends */}
        <Card>
          <CardHeader>
            <CardTitle>Monthly Spending Trend</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={stats.monthlyTrends}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis tickFormatter={(value) => `$${value.toLocaleString()}`} />
                <Tooltip formatter={(value) => formatCurrency(value as number)} />
                <Line
                  type="monotone"
                  dataKey="amount"
                  stroke="#3B82F6"
                  strokeWidth={2}
                  dot={{ fill: '#3B82F6' }}
                />
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </div>

      {/* Recent Receipts */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Receipts</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {stats.recentReceipts.map((receipt) => (
              <div key={receipt.id} className="flex items-center justify-between p-3 border rounded">
                <div>
                  <div className="font-medium">{receipt.vendor_name}</div>
                  <div className="text-sm text-muted-foreground">
                    {new Date(receipt.receipt_date).toLocaleDateString()}
                  </div>
                </div>
                <div className="text-right">
                  <div className="font-medium">{formatCurrency(receipt.total_amount)}</div>
                  {receipt.category_name && (
                    <Badge variant="secondary" className="text-xs">
                      {receipt.category_name}
                    </Badge>
                  )}
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
```

## Phase 5: Advanced Features & Export

### 5.1 CSV/PDF Export Functionality

**Priority:** High
**Estimated Time:** 8-10 hours

```typescript
// lib/services/export-service.ts
import { jsPDF } from 'jspdf'
import 'jspdf-autotable'

export interface ExportOptions {
  format: 'csv' | 'pdf'
  dateRange: { start: Date; end: Date }
  categories?: string[]
  includeImages?: boolean
}

export class ExportService {
  async exportReceipts(options: ExportOptions): Promise<Blob> {
    // Fetch receipts based on options
    let query = supabase
      .from('receipts')
      .select(`
        *,
        categories (name)
      `)
      .gte('receipt_date', options.dateRange.start.toISOString().split('T')[0])
      .lte('receipt_date', options.dateRange.end.toISOString().split('T')[0])

    if (options.categories?.length) {
      query = query.in('category_id', options.categories)
    }

    const { data: receipts, error } = await query.order('receipt_date', { ascending: false })

    if (error) throw error

    if (options.format === 'csv') {
      return this.generateCSV(receipts || [])
    } else {
      return this.generatePDF(receipts || [], options.includeImages || false)
    }
  }

  private generateCSV(receipts: any[]): Blob {
    const headers = [
      'Date',
      'Vendor',
      'Amount',
      'Category',
      'Payment Method',
      'Business Purpose',
      'Notes',
      'Tags'
    ]

    const csvContent = [
      headers.join(','),
      ...receipts.map(receipt => [
        receipt.receipt_date,
        `"${receipt.vendor_name}"`,
        receipt.total_amount,
        `"${receipt.categories?.name || ''}"`,
        receipt.payment_method,
        `"${receipt.business_purpose || ''}"`,
        `"${receipt.notes || ''}"`,
        `"${receipt.tags?.join(', ') || ''}"`
      ].join(','))
    ].join('\n')

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  }

  private async generatePDF(receipts: any[], includeImages: boolean): Promise<Blob> {
    const doc = new jsPDF()

    // Title
    doc.setFontSize(20)
    doc.text('Receipt Export Report', 20, 30)

    // Summary
    const totalAmount = receipts.reduce((sum, r) => sum + r.total_amount, 0)
    doc.setFontSize(12)
    doc.text(`Total Receipts: ${receipts.length}`, 20, 50)
    doc.text(`Total Amount: $${totalAmount.toFixed(2)}`, 20, 60)
    doc.text(`Export Date: ${new Date().toLocaleDateString()}`, 20, 70)

    // Table data
    const tableData = receipts.map(receipt => [
      receipt.receipt_date,
      receipt.vendor_name,
      `$${receipt.total_amount.toFixed(2)}`,
      receipt.categories?.name || '',
      receipt.payment_method,
      receipt.business_purpose || ''
    ])

    // Add table
    ;(doc as any).autoTable({
      head: [['Date', 'Vendor', 'Amount', 'Category', 'Payment', 'Purpose']],
      body: tableData,
      startY: 80,
      styles: { fontSize: 10 },
      headStyles: { fillColor: [59, 130, 246] }
    })

    // Add images if requested
    if (includeImages) {
      let yPosition = (doc as any).lastAutoTable.finalY + 20

      for (const receipt of receipts.slice(0, 10)) { // Limit to first 10 for PDF size
        if (receipt.image_url && yPosition < 250) {
          try {
            // Convert image to base64 and add to PDF
            // This is a simplified version - real implementation would need proper image handling
            doc.text(`${receipt.vendor_name} - ${receipt.receipt_date}`, 20, yPosition)
            yPosition += 10
          } catch (error) {
            console.warn('Failed to add image:', error)
          }
        }
      }
    }

    return new Blob([doc.output('blob')], { type: 'application/pdf' })
  }
}
```

### 5.2 Search and Filtering System

**Priority:** Medium
**Estimated Time:** 6-8 hours

```typescript
// components/receipts/advanced-search.tsx
'use client'

import { useState } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Checkbox } from '@/components/ui/checkbox'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Calendar } from '@/components/ui/calendar'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { Badge } from '@/components/ui/badge'
import { CalendarIcon, X, Search } from 'lucide-react'
import { format } from 'date-fns'

export interface SearchFilters {
  searchTerm?: string
  dateRange?: { start: Date; end: Date }
  categories?: string[]
  paymentMethods?: string[]
  amountRange?: { min: number; max: number }
  tags?: string[]
  needsReview?: boolean
  lowConfidence?: boolean
}

interface AdvancedSearchProps {
  onFiltersChange: (filters: SearchFilters) => void
  onClose: () => void
}

export function AdvancedSearch({ onFiltersChange, onClose }: AdvancedSearchProps) {
  const [filters, setFilters] = useState<SearchFilters>({})
  const [categories, setCategories] = useState<Array<{ id: string; name: string }>>([])
  const [allTags, setAllTags] = useState<string[]>([])

  const updateFilter = (key: keyof SearchFilters, value: any) => {
    const newFilters = { ...filters, [key]: value }
    setFilters(newFilters)
  }

  const applyFilters = () => {
    onFiltersChange(filters)
    onClose()
  }

  const clearFilters = () => {
    setFilters({})
    onFiltersChange({})
  }

  return (
    <Card className="w-full max-w-4xl">
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>Advanced Search</span>
          <Button variant="ghost" size="sm" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Text Search */}
        <div className="space-y-2">
          <Label>Search Terms</Label>
          <div className="relative">
            <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search vendor names, notes, business purpose..."
              value={filters.searchTerm || ''}
              onChange={(e) => updateFilter('searchTerm', e.target.value)}
              className="pl-10"
            />
          </div>
        </div>

        {/* Date Range */}
        <div className="space-y-2">
          <Label>Date Range</Label>
          <div className="flex gap-2">
            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" className="flex-1 justify-start text-left">
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {filters.dateRange?.start ? format(filters.dateRange.start, 'PPP') : 'Start date'}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="single"
                  selected={filters.dateRange?.start}
                  onSelect={(date) => updateFilter('dateRange', { ...filters.dateRange, start: date })}
                  initialFocus
                />
              </PopoverContent>
            </Popover>

            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" className="flex-1 justify-start text-left">
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {filters.dateRange?.end ? format(filters.dateRange.end, 'PPP') : 'End date'}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="single"
                  selected={filters.dateRange?.end}
                  onSelect={(date) => updateFilter('dateRange', { ...filters.dateRange, end: date })}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
          </div>
        </div>

        {/* Amount Range */}
        <div className="space-y-2">
          <Label>Amount Range</Label>
          <div className="flex gap-2">
            <div className="flex-1">
              <Input
                type="number"
                placeholder="Min amount"
                value={filters.amountRange?.min || ''}
                onChange={(e) => updateFilter('amountRange', {
                  ...filters.amountRange,
                  min: parseFloat(e.target.value) || 0
                })}
              />
            </div>
            <div className="flex-1">
              <Input
                type="number"
                placeholder="Max amount"
                value={filters.amountRange?.max || ''}
                onChange={(e) => updateFilter('amountRange', {
                  ...filters.amountRange,
                  max: parseFloat(e.target.value) || 0
                })}
              />
            </div>
          </div>
        </div>

        {/* Categories */}
        <div className="space-y-2">
          <Label>Categories</Label>
          <div className="grid grid-cols-2 gap-2">
            {categories.map((category) => (
              <div key={category.id} className="flex items-center space-x-2">
                <Checkbox
                  id={category.id}
                  checked={filters.categories?.includes(category.id) || false}
                  onCheckedChange={(checked) => {
                    const currentCategories = filters.categories || []
                    if (checked) {
                      updateFilter('categories', [...currentCategories, category.id])
                    } else {
                      updateFilter('categories', currentCategories.filter(id => id !== category.id))
                    }
                  }}
                />
                <Label htmlFor={category.id}>{category.name}</Label>
              </div>
            ))}
          </div>
        </div>

        {/* Payment Methods */}
        <div className="space-y-2">
          <Label>Payment Methods</Label>
          <div className="flex gap-2">
            {['cash', 'card', 'digital'].map((method) => (
              <div key={method} className="flex items-center space-x-2">
                <Checkbox
                  id={method}
                  checked={filters.paymentMethods?.includes(method) || false}
                  onCheckedChange={(checked) => {
                    const currentMethods = filters.paymentMethods || []
                    if (checked) {
                      updateFilter('paymentMethods', [...currentMethods, method])
                    } else {
                      updateFilter('paymentMethods', currentMethods.filter(m => m !== method))
                    }
                  }}
                />
                <Label htmlFor={method} className="capitalize">{method}</Label>
              </div>
            ))}
          </div>
        </div>

        {/* Status Filters */}
        <div className="space-y-2">
          <Label>Status</Label>
          <div className="flex gap-4">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="needs-review"
                checked={filters.needsReview || false}
                onCheckedChange={(checked) => updateFilter('needsReview', checked)}
              />
              <Label htmlFor="needs-review">Needs Review</Label>
            </div>

            <div className="flex items-center space-x-2">
              <Checkbox
                id="low-confidence"
                checked={filters.lowConfidence || false}
                onCheckedChange={(checked) => updateFilter('lowConfidence', checked)}
              />
              <Label htmlFor="low-confidence">Low OCR Confidence</Label>
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-between pt-4">
          <Button variant="outline" onClick={clearFilters}>
            Clear All
          </Button>
          <div className="flex gap-2">
            <Button variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button onClick={applyFilters}>
              Apply Filters
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
```

## Phase 6: UI/UX Enhancement

### 6.1 Modern Design System Implementation

**Priority:** High
**Estimated Time:** 12-15 hours

**Design Principles:**
- Clean, modern interface inspired by Linear, Notion
- Consistent color scheme and typography
- Responsive design for all devices
- Accessibility compliance (WCAG 2.1 AA)
- Progressive Web App features

**Key Components to Enhance:**

1. **Navigation & Layout**
2. **Form Components**
3. **Data Tables & Lists**
4. **Dashboard Cards**
5. **Mobile-First Responsive Design**

### 6.2 Mobile App UI Polish

**Priority:** High
**Estimated Time:** 10-12 hours

**React Native Enhancements:**
- Implement custom camera overlay with receipt edge detection
- Add haptic feedback for better UX
- Implement pull-to-refresh patterns
- Add offline support with local storage
- Implement proper loading states and error boundaries

## Phase 7: Testing & Quality Assurance

### 7.1 Comprehensive Test Suite

**Priority:** Medium
**Estimated Time:** 15-20 hours

**Testing Strategy:**
1. **Unit Tests** - Core business logic and utilities
2. **Integration Tests** - Database operations and API endpoints
3. **E2E Tests** - Critical user flows (signup → capture → export)
4. **Performance Tests** - Image upload, OCR processing
5. **Accessibility Tests** - Screen reader compatibility
6. **Cross-Platform Tests** - Web and mobile feature parity

### 7.2 Performance Optimization

**Priority:** Medium
**Estimated Time:** 8-10 hours

**Optimization Areas:**
- Image compression and lazy loading
- Database query optimization
- Caching strategy for frequently accessed data
- Bundle size optimization for web app
- Mobile app performance profiling

## Implementation Timeline & Priorities

### Week 1-2: Foundation (Phase 1-2)
- **Days 1-3:** Database schema and migrations
- **Days 4-7:** Storage configuration and file upload service
- **Days 8-14:** Receipt capture functionality (web + mobile)

### Week 3-4: Core Features (Phase 3-4)
- **Days 15-21:** OCR integration and data extraction
- **Days 22-28:** Receipt management interface and dashboard

### Week 5-6: Advanced Features (Phase 5)
- **Days 29-35:** Export functionality and advanced search
- **Days 36-42:** UI/UX enhancements and polish

### Week 7-8: Testing & Launch Prep (Phase 6-7)
- **Days 43-49:** Comprehensive testing and bug fixes
- **Days 50-56:** Performance optimization and final polish

## Risk Mitigation & Contingency Plans

### Technical Risks
1. **OCR Accuracy Issues**
   - Fallback: Manual data entry with assisted suggestions
   - Alternative: Multiple OCR providers for comparison

2. **File Upload Performance**
   - Mitigation: Implement progressive image compression
   - Fallback: Queue-based processing for large files

3. **Cross-Platform Compatibility**
   - Strategy: Shared component library approach
   - Testing: Comprehensive device testing matrix

### Business Risks
1. **User Adoption**
   - Mitigation: Intuitive onboarding flow
   - Strategy: Progressive feature introduction

2. **Data Security Concerns**
   - Compliance: GDPR/CCPA data handling policies
   - Security: End-to-end encryption for sensitive data

## Success Metrics & KPIs

### Technical Metrics
- Upload success rate > 95%
- OCR accuracy > 80%
- App load time < 3 seconds
- Crash rate < 1%

### User Experience Metrics
- Time to capture first receipt < 2 minutes
- User retention rate > 60% after 30 days
- Feature adoption rate for export > 40%
- User satisfaction score > 4.0/5.0

### Business Metrics
- Monthly active users growth
- Receipt processing volume
- Export feature usage
- Support ticket volume (should decrease)

## Post-MVP Roadmap

### Phase 8: Advanced Analytics (Month 3-4)
- Spending trend analysis
- Tax deduction optimization
- Budget tracking and alerts
- Integration with accounting software (QuickBooks, Xero)

### Phase 9: AI Enhancement (Month 4-5)
- Smart categorization using ML
- Duplicate detection and merging
- Expense policy compliance checking
- Predictive analytics for spending patterns

### Phase 10: Enterprise Features (Month 5-6)
- Multi-user accounts and permissions
- Team expense management
- Advanced reporting and analytics
- API for third-party integrations

## Resource Requirements

### Development Team
- **1 Full-Stack Developer** (40 hrs/week) - Web & Mobile development
- **0.5 Backend Developer** (20 hrs/week) - Database optimization & OCR integration
- **0.25 UI/UX Designer** (10 hrs/week) - Design system and user experience
- **0.25 QA Engineer** (10 hrs/week) - Testing and quality assurance

### External Services & Costs
- **Supabase Pro Plan:** $25/month (includes database, storage, auth)
- **Google Vision API:** ~$1.50 per 1,000 OCR requests
- **CDN & Image Optimization:** ~$10/month
- **Development Tools:** ~$50/month (various subscriptions)

### Infrastructure
- **Production Environment:** Vercel Pro ($20/month) or similar
- **Mobile App Distribution:** Apple App Store ($99/year) + Google Play ($25 one-time)
- **Monitoring & Analytics:** Sentry, PostHog or similar (~$30/month)

**Total Monthly Operating Cost:** ~$135-150/month

## Conclusion

This comprehensive plan transforms the current basic authentication system into a production-ready MVP receipt management application. The phased approach ensures steady progress while maintaining system stability and user experience quality.

Key differentiators of this MVP:
1. **Cross-Platform Consistency** - Shared database with native experiences
2. **Intelligent OCR Processing** - Automated data extraction with manual fallback
3. **Professional UI/UX** - Modern design system comparable to premium productivity apps
4. **Comprehensive Export** - Multiple formats for accounting and tax purposes
5. **Advanced Search & Analytics** - Powerful insights into spending patterns

The implementation timeline is aggressive but achievable with dedicated focus and proper resource allocation. The modular approach allows for incremental delivery and user feedback incorporation throughout the development process.